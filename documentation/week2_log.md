This week the project goals focused around algorithm implementations, specifically to implement the one-dimensional algorithms: Bisection, Secant, Newton-Raphson, Golden Search in Python, to test them in Jupyter notebooks and compare to existing Python packages (like SciPy), and to use GenAI to implement basic visualization plots with Plotly for each algorithm’s output.

I began with implementing the one-dimensional algorithms, and then prompted Gemini to create a Jupyter Notebook to test the algorithms with SciPy and NumPy. I did run into some problems with Gemini creating the testing notebook as it failed to properly format the file as a JSON. I fed it the error message that Jupyter told me and continued to fail to produce a working notebook 3 more times. At one point, it decided to write a python script to create the Jupyter notebook and this still failed. Finally, it decided to create the python script line by line, which was incredibly slow and BLANK. This whole error process took about 20 minutes, before Gemini completely broke and glitched out. I decided to create the notebook myself and see if Gemini could still write the code to check the algorithms. Which it did, but it wanted me to add the code manually to the Jupyter notebook in fear of messing it up again. Images of the error process and work through can be found in screenshots/week2. 

The notebook can be found in the testing_notebooks folder, and the results showed that my implementations were correct against SciPy and NumPy using well-known example functions and results taken from the literature in the project proposal. However, I spent quite some time debugging the test and ran across an interesting fact about SciPy's Golden Search which is that it does not strictly enforce the bracket boundaries. I also decided to format my screenshots by weeks for organization.

I attempted to create basic animated visualizations of the one-dimensional algorithms from this week with Gemini CLI. At first, we had a few discussions about why it is important to visualize the algorithms in matplotlib before the final interactive web application, so we can understand what exactly should be visualized or interactive. For example, with the bisection and secant method, Gemini suggested redefining my algorithm to yield the values of a, b, and mid (or x0, x1, x2) each iteration. 

Additionally, for bisection, I asked Gemini what it thinks should happen if one of the roots is given as one of the input values, to which it suggested adding an edge case check for this at the beginning, instead of erroring out. This update was added to the Secant visualization file too. In the Newton-Raphson, the animation that Gemini produced was good, but it showed the tangent line only going in one direction, which felt less intuitive that it is a tangent line not just an arrow to 0. Therefore, I prompted Gemini to fix this, and it did. Also for golden search, I ran into some problems with the requirement of the input function to be unimodal, which is too difficult and costly to check in the algorithm, therefore if I allow users to input functions in the app, it must be clear that they can only input unimodal functions or else it will fail. The golden search visualization I spent quite some time with, as one of the functions kept failing despite passing in the testing notebook, and I was trying to work with Gemini to craft a way to show the 38.2% reduction in bracketing that defines Golden Search. I ended up not liking any of Gemini’s suggestions, and prompted it to shade the 38.2% versus the rest to showcase it, which turned out much more intuitive and clear. The final visualizations can be found in the visualizations folder, inside the one-dimensional folder.
