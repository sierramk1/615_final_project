This week I chose to pivot back to the algorithms to work on visualizing the two multidimensional algorithms.
	I replicated much of the structure of the one-dimensional algorithms page, with function input, initial guess, and algorithmic specific details, as well as the number of dimensions.In the gradient descent algorithm in multiple dimensions, I chose to visualize this by showing the path the algorithm takes across the function’s surface. Since the function now has more than one input variable, I use a contour plot (or 3D surface plot) to represent the function’s landscape. The algorithm’s iterations are overlaid as points or arrows to show how it moves toward the minimum. This allows users to see not only the convergence behavior but also the trajectory through the “valleys” and “ridges” of the function. I also included a pseudocode display so that users can connect the visual path with the underlying computational steps, making the algorithm’s behavior clear in higher dimensions.
	For functions or data greater than three dimensions, I chose to show convergence plots and tables of iteration coordinates, so users can track the algorithm’s progress even when it’s not possible to visualize all dimensions at once.I ran into some interesting errors with Gemini, specifically a use of NOOP, no-operation command that forced me to allow it to be run despite telling Gemini to stop using that. NOOP was just a no operation command that allowed Gemini to print something to me, but generally in the past few weeks Gemini could just speak to me without needing permission for a NOOP command. This was completely new to me, and I attempted to stop it by using the save-memory command to tell Gemini not to use it, but Gemini would not save this fact to memory, despite me feeding the save-memory command and details several times. 
	I will say that when I transitioned my project from backend to frontend only this week, Gemini was very helpful. I asked it how long it expected this process to take and it estimated 2-3 days of work, but it only took Gemini about 30 minutes to convert the necessary files, restructure the project, and update other dependent files. This impressed me, and felt like a great use of Gemini to accomplish a complicated task in a short amount of time. Also, I think one of the benefits of collaborating with Gemini is that I have learned more about how to debug an application by using console logs. I would have never known how to work through many of the problems I have encountered with Gemini, but to learn how Gemini handles them has been incredibly beneficial.
	At some point we were working through a bug in the frontend and when I went to check the files in VSCode, and they were empty. I accused Gemini of corrupting the files, but it denied touching those files.  This came up multiple times this week with several different files. I am not sure if it is related to the fallback/default version of Gemini used when I hit my limit of the pro for the day but it is quite frustrating, and a major con of using Gemini.  Moreover,  I did some personal research into this problem to see if it really was Gemini that seemed to empty my files without ever asking me or claiming to have touched those files. I found some interesting articles about people losing all of their files thanks to Gemini CLI, which is truly awful for them, but nice to know I wasn’t alone in this problem. This has led me to believe that it is best to use Gemini CLI in a smaller directory you want to work on, instead of an entire project or your whole Desktop. In general, I have lost trust in Gemini.
The article and forum I found:https://news.ycombinator.com/item?id=44651485
https://dev.ua/en/news/ya-povnistiu-i-katastrofichno-pidviv-vas-1753427615
